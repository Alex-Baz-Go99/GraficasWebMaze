<html>

<head>
	<title>2.3 Colisiones</title>
	<script type="text/javascript" src="js/libs/jquery/jquery-2.1.4.min.js"></script>
	<script type="text/javascript" src="js/libs/three/three.js"></script>
	<script type="text/javascript" src="js/libs/three/MTLLoader.js"></script>
	<script type="text/javascript" src="js/libs/three/OBJLoader.js"></script>
	<script type="text/javascript">

		var scene;
		var camera;
		var renderer;
		var controls;

		var mainModeWalls = [
			[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [0, 10], [0, 11], [0, 12], [0, 13], [0, 14], [0, 15], [0, 16], [0, 17], [0, 18], [0, 19],
			[1, 6], [1, 19],
			[2, 0], [2, 2], [2, 3], [2, 4], [2, 6], [2, 8], [2, 10], [2, 11], [2, 12], [2, 19],
			[3, 0], [3, 8], [3, 11], [3, 14], [3, 15], [3, 16], [3, 17], [3, 19],
			[4, 0], [4, 2], [4, 4], [4, 5], [4, 6], [4, 8], [4, 9], [4, 11], [4, 13], [4, 14], [4, 19],
			[5, 0], [5, 8], [0, 9], [5, 16], [5, 17], [5, 19],
			[6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 8], [6, 10], [6, 11], [6, 12], [6, 14], [6, 19],
			[7, 0], [7, 17], [7, 19],
			[8, 0], [8, 2], [8, 4], [8, 5], [8, 6], [8, 7], [8, 9], [8, 10], [8, 11], [8, 13], [8, 15], [8, 19],
			[9, 0], [9, 2], [9, 13], [9, 17], [9, 19],
			[10, 0], [10, 2], [10, 3], [10, 4], [10, 5], [10, 6], [10, 7], [10, 9], [0, 10], [10, 11], [10, 12], [10, 13], [10, 14], [10, 19],
			[11, 0], [11, 11], [11, 16], [11, 17], [11, 19],
			[12, 0], [12, 2], [12, 3], [12, 5], [12, 7], [12, 8], [12, 10], [12, 11], [12, 13], [12, 14], [12, 16], [12, 19],
			[13, 0], [13, 2], [13, 5], [13, 7], [13, 8], [13, 13], [13, 14], [13, 16], [13, 18], [13, 19],
			[14, 0], [14, 4], [14, 5], [14, 10], [14, 11], [14, 19],
			[15, 0], [15, 2], [15, 4], [15, 5], [15, 7], [15, 8], [15, 10], [15, 11], [15, 13], [15, 14], [15, 16], [15, 17], [15, 19],
			[16, 0], [0, 19],
			[17, 0], [17, 1], [17, 2], [17, 3], [17, 4], [17, 5], [17, 6], [17, 7], [17, 8], [17, 9], [17, 10], [17, 11], [17, 12], [17, 13], [17, 14], [17, 16], [17, 17], [17, 18], [17, 19],
			[18, 0], [18, 1], [18, 2], [18, 3], [18, 4], [18, 5], [18, 6], [18, 7], [18, 8], [18, 9], [18, 10], [18, 11], [18, 12], [18, 13], [18, 14], [18, 16], [18, 17], [18, 18], [18, 19],
			[19, 0], [19, 1], [19, 2], [19, 3], [19, 4], [19, 5], [19, 6], [19, 7], [19, 8], [19, 9], [19, 10], [19, 11], [19, 12], [19, 13], [190, 14], [19, 15], [19, 16], [19, 17], [19, 18], [19, 19]
		];

		var escenario = [
			{path:"assets/MainMode/Bosque/Escenario/", obj:"cuboHojas.obj", mtl: "cuboHojas.mtl"},
			{path:"assets/MainMode/Medieval/Escenario/", obj:"cuboLadrillo.obj", mtl: "cuboLadrillo.mtl"},
			{path:"assets/MainMode/Futurista/Escenario/", obj:"cuboFuturista.obj", mtl: "cuboFuturista.mtl"}];

		var geometriaCubo = new THREE.BoxGeometry(10, 10, 10);
		var materialCubo = new THREE.MeshLambertMaterial({ color: new THREE.Color(0, 0.6, 0.7), wireframe: false });


		var objects = {
			boxes: "boxes",
			fakeBoxes: "fakeBoxes",
			decorators: "decorators",
			spikes: "spikes",
			crushWalls: "crushWalls",
			mannequins: "mannequins",
		};

		objects.boxes = [];
		objects.fakeBoxes = [{ x: "coordX", y: "posy", z: "coordZ" }];
		objects.decorators = [{ x: "coordX", y: "posy", z: "coordZ" }];
		objects.spikes = [{ x: "coordX", y: "posy", z: "coordZ" }];
		objects.crushWalls = [{ x: "coordX", y: "posy", z: "coordZ" }];
		objects.mannequins = [{ x: "coordX", y: "posy", z: "coordZ" }];

		var clock;
		var deltaTime;
		var keys = {};
		var moto;

		// Clase que nos permite "lanzar" un rayo hacia diferentes direcciones
		// y detectar si el "rayo" colisiona con un objeto en esa direccion
		var rayCaster;
		var collisionObjects = [];
		var isWorldReady = [false, false];
		$(document).ready(function () {

			setupScene();
			rayCaster = new THREE.Raycaster();

			function positionObject(object, mesh = new THREE.Mesh(geometriaCubo, materialCubo)) {
				if (object == "testbox") {

					var geometria = new THREE.BoxGeometry(10, 10, 10);
					var material = new THREE.MeshLambertMaterial({ color: new THREE.Color(0, 0.6, 0.7), wireframe: false });

					cubo = new THREE.Mesh(geometria, material);

					cubo.position.z = -40;
					cubo.position.x = -44;
					cubo.position.y = 5;

					mainModeWalls.forEach(function (element) {
						var asset = cubo.clone();

						asset.coordZ = element[0];
						asset.coordX = element[1];
						asset.position.x += asset.coordX * 10;
						asset.position.z += asset.coordZ * 10;
						objects.boxes.push(asset);
					});

					objects.boxes.forEach(function (box) {
						collisionObjects.push(box);
					});
				}

				if (object == "wallblock") {
					mainModeWalls.forEach(function (element) {
						var asset = mesh.clone();

						asset.position.z = -40;
						asset.position.x = -44;
						asset.position.y = 0;

						asset.coordZ = element[0];
						asset.coordX = element[1];
						asset.position.x += asset.coordX * 10;
						asset.position.z += asset.coordZ * 10;
						objects.boxes.push(asset);
					});

					objects.boxes.forEach(function (box) {
						collisionObjects.push(box);
					});
				}
			}

			loadOBJWithMTL("assets/", "laPared.obj", "laParedFuturo.mtl", (object) => {
				/*//Primera pared-----------------------------------------------------------------------------
				object.position.z = -43;
				object.position.x = 34;
				object.position.y = -2;
				//object.scale.set(1.92,2,1);
				object.scale.set(1.92, 2,1);
	
				var box2 = object.clone();
				box2.position.x = -0.4;
			
				var box3 = object.clone();
				box3.position.x = -33;
				
	
				collisionObjects.forEach(function(pared){
					scene.add(pared);
				})
	
				isWorldReady[0] = true;*/
			});

			loadOBJWithMTL("assets/", "jetski.obj", "jetski.mtl", (object) => {
				object.position.z = -26;
				object.rotation.x = THREE.Math.degToRad(-90);
				object.rotation.z = THREE.Math.degToRad(90);

				object.name = "moto";

				scene.add(object);
				collisionObjects.push(object);//colision con la moto
				isWorldReady[1] = true;
			});

			loadOBJWithMTL("assets/", "plataforma.obj", "plataforma.mtl", (object) => {
				object.position.z = 1;
				object.position.y = -1;
				object.scale.set(2.3, 1, 2.13);

				scene.add(object);
				collisionObjects.push(object);//colision con la moto
				//isWorldReady[2] = true;
			});

			loadOBJWithMTL(escenario[1].path, escenario[1].obj, escenario[1].mtl, (object) => {

				positionObject("wallblock", object);

				objects.boxes.forEach(function (block) {
					scene.add(block);
				});

				collisionObjects.forEach(function (object) {
					scene.add(object);
				});

				isWorldReady[0] = true;

			});

			(function () {

				/*var geometria = new THREE.BoxGeometry(10, 10, 10);
				var material = new THREE.MeshLambertMaterial( { color: new THREE.Color(0.7, 0, 0), wireframe:true } );
				
				cubo = new THREE.Mesh(geometria, material);
				cubo2 = cubo.clone();
				
				cubo.position.z = -40;
				cubo.position.x = 56;
				cubo.position.y = 5;
				
				collisionObjects.push(cubo);
	
				cubo2.position.z = cubo.position.z + 90;
				cubo2.position.x = cubo.position.x - 90;
	
				collisionObjects.push(cubo2);*/


				// positionObject("testbox");

				// collisionObjects.forEach(function(block){
				// 	scene.add(block);
				// })

				// isWorldReady[0] = true;
			}());

			render();

			document.addEventListener('keydown', onKeyDown);
			document.addEventListener('keyup', onKeyUp);
		});

		function loadOBJWithMTL(path, objFile, mtlFile, onLoadCallback) {
			var mtlLoader = new THREE.MTLLoader();
			mtlLoader.setPath(path);
			mtlLoader.load(mtlFile, (materials) => {

				var objLoader = new THREE.OBJLoader();
				objLoader.setMaterials(materials);
				objLoader.setPath(path);
				objLoader.load(objFile, (object) => {
					onLoadCallback(object);
				});

			});
		}

		function onKeyDown(event) {
			keys[String.fromCharCode(event.keyCode)] = true;
		}

		function onKeyUp(event) {
			keys[String.fromCharCode(event.keyCode)] = false;
		}

		function render() {
			requestAnimationFrame(render);
			deltaTime = clock.getDelta();
			moto = scene.getObjectByName("moto");
			var yaw = 0;
			var forward = 0;
			if (keys["A"]) {
				yaw = 5;
			} else if (keys["D"]) {
				yaw = -5;
			}
			if (keys["W"]) {
				forward = -20;
			} else if (keys["S"]) {
				forward = 20;
			}


			if (isWorldReady[0] && isWorldReady[1]) {
				moto.rotation.z += yaw * deltaTime;
				moto.translateX(forward * deltaTime);

				camera.position.x = moto.position.x;
				camera.position.z = moto.position.z + 30;

				// Collision
				// Recorremos los "rayos" a lanzar para detectar las colisiones
				for (var i = 0; i < camera.rays.length; i++) {
					// Lanzamos el rayo
					// El primero parametro es para saber desde donde vamos a lanzar el rayo (desde la camara)
					// El segundo parametro es para saber la direccion a la cual lanzaremos el rayo
					rayCaster.set(moto.position, camera.rays[i]);
					// Verificamos si hay colision con algun objeto.
					// El primer parametro es el objeto o la coleccion de objetos 
					// los cuales vamos a tomar en cuenta para colisionar
					// El segundo parametro es para indicar que aparte de verificar
					// si existe colision con estos objetos tambien verifique colision con los hijos de estos objetos
					var collision = rayCaster.intersectObjects(collisionObjects, true);

					// if(collision.length){
					// 	console.log(collision[0].distance);
					// }
					// else{
					// 	console.log("nada");
					// }

					// En el if podemos ver que tambien tenemos control para saber a que distancia esta colisionando
					if (collision.length > 0 && collision[0].distance < 1) {
						console.log("colisionando");
						//Profe, esta fue la solución que encontré después de 4 horas, solo son 2 líneas de código evita que atravieses las cajas y te hace retroceder si quieres pasar a través de ellas
						moto.translateX(-(forward * deltaTime));

					}

				}
			}


			renderer.render(scene, camera);
		}

		function setupScene() {
			var visibleSize = { width: window.innerWidth, height: window.innerHeight };
			clock = new THREE.Clock();
			scene = new THREE.Scene();
			//camera = new THREE.PerspectiveCamera(100, visibleSize.width / visibleSize.height, 0.1, 120);

			var aspect = window.innerWidth / window.innerHeight;
			var d = 70;
			camera = new THREE.OrthographicCamera(- d * aspect, d * aspect, d, - d, 1, 1000);
			camera.position.set(50, 60, 70); // all components equal
			camera.lookAt(0, 0, 0); // or the origin

			//camera.rotation.y = THREE.Math.degToRad(-5);
			camera.rotation.x = THREE.Math.degToRad(-70);

			camera.rays = [
				new THREE.Vector3(1, 0, 0),
				new THREE.Vector3(-1, 0, 0),
				new THREE.Vector3(0, 0, 1),
				new THREE.Vector3(0, 0, -1),
			];

			renderer = new THREE.WebGLRenderer({ precision: "mediump" });
			renderer.setClearColor(new THREE.Color(0, 0, 0));
			renderer.setPixelRatio(visibleSize.width / visibleSize.height);
			renderer.setSize(visibleSize.width, visibleSize.height);

			var ambientLight = new THREE.AmbientLight(new THREE.Color(1, 1, 1), 1.0);
			scene.add(ambientLight);

			var directionalLight = new THREE.DirectionalLight(new THREE.Color(1, 1, 0), 0.4);
			directionalLight.position.set(0, 0, 1);
			scene.add(directionalLight);

			var grid = new THREE.GridHelper(200, 50, 0xffffff, 0xffffff);
			grid.position.y = -1;
			//scene.add(grid);

			$("#scene-section").append(renderer.domElement);
		}


	</script>
</head>

<body>

	<div id="scene-section" />

</body>

</html>